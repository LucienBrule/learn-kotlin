
## Recap

So assuming you read [[Preparing To Write Code]], you have this directory structure:
```
~/Developer
❯ tre
.
├── etc
│   ├── dotfiles
│   ├── secrets
│   └── notes
├── opt
│   └── oss
└── src
    ├── archive
    ├── scratch
    └── active
```

You hopefully also already did the part where you used SDKMAN! and chose a JVM and have IntelliJ Idea Installed. We won't be using the latter yet but, go do that and let it download before you do the rest of this. 


## Hello World

Wow, if you've gone through this sequentially you're probably like, when are we going to right actual Kotlin? To that I say patience is a virtue. Our current goal will be:

- Setup a codebase
- Setup our build scripts
- Write a Hello, World! Program
- Build Hello, World!
- Run Hello, World!

#### Setup a Codebase

```bash
cd ~/Developer/src/scratch
mkdir kotlin-hello-world
cd ~/Developer/src/scratch/kotlin-hello-world
```

> ProTip: Hit \[TAB\] after directories you know are there when navigating in your shell to autocomplete the directory / file names. If you're on bash and have it setup right or on sh by default, you can hit tab twice and get a little ls style picker of where to go. Very nice

Now we want to generate code, if you installed an SDK earlier, you'll also have gradle. 
We're going to 'cheat' doing this the hard way, then I'll explain how to actually do things the hard way. For sake of learning. 

```bash
gradle init --type kotlin-application --dsl kotlin --project-name kotlin-hello-world --package com.example.hello

Starting a Gradle Daemon (subsequent builds will be faster)

Enter target version of Java (min. 7) (default: 21): 20

Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no] no


> Task :init
To learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.4/samples/sample_building_kotlin_applications.html

BUILD SUCCESSFUL in 22s
2 actionable tasks: 2 executed
```

Now we run `tre`, and see what we got~

```
❯ tre
.
├── app
│   ├── build.gradle.kts
│   └── src
│       ├── test
│       │   ├── resources
│       │   └── kotlin
│       │       └── com
│       │           └── example
│       │               └── hello
│       │                   └── AppTest.kt
│       └── main
│           ├── resources
│           └── kotlin
│               └── com
│                   └── example
│                       └── hello
│                           └── App.kt
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── settings.gradle.kts
└── gradlew.bat
```

Looks like we have a proper single application structure. 

Here's a rundown of the flags we used, and the quiz items we had to fill out

- gradle init : tells Gradle to intitialize a new project
- --type kotlin-application : Specifies we want a Kotlin application project
- --dsl kotlin : Tells Gradle to use kotlin DSL for build scripts (so we get build.gradle.lts), and don't have to write Groovy
- --project-name kotlin-hello-world : Sets the project name
- --package com.example.hellow : Defines the base package for our Kotlin code

#### Setup Our Buildscripts

We kinda already did this in one shot in the section before, but if you're really doing this the hard way, you would make a directory for your code, and manually do what gradle init does for you. 

**Namely**

- make a project directory 
- make a settings.gradle.kts
- make a build.gradle.kts
- make a src directory
- make a main/kotlin directory
- put a file under src/main/kotlin
- run gradle init (to get gradlew scripts)

Note gradle init with the flags we gave it does some arguably extraneous things, for instance a package name and java style package structure isn't strictly required, and a tests directory isn't required either. 

Lets take a look at what gradle init made for us, and what we would have to put in our files if we were doing this by manually.

```kotlin
// ❯ cat settings.gradle.kts
/*
 * This file was generated by the Gradle 'init' task.
 *
 * The settings file is used to specify which projects to include in your build.
 * For more detailed information on multi-project builds, please refer to https://docs.gradle.org/8.4/userguide/building_swift_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the foojay-resolver plugin to allow automatic download of JDKs
    id("org.gradle.toolchains.foojay-resolver-convention") version "0.7.0"
}

rootProject.name = "kotlin-hello-world"
include("app")
```

You don't ~need~ the foojay resolver plugin, but yeah if you're targeting the JVM you do, so that's good.

`rootProject.name` is the first thing that actually matters. When making a new file by hand, that's the first line. Also if you intend on making this an intellij project, try and make your `rootProject.name` the same name as the root project directory, or else it'll be this ugly bracketed notation in your file tree. 

 What is `include("app")` ? As we'll find out later, especially when we do multi module projects having the includes at the top of the `settings.gradle.kts` file is really handy. You might be wondering, where is "app"? That's a good question. By convention when you do `include("some-module")` it's usually the file path to a directory with a `build.gradle.kts`


```kotlin
// ❯ cat app/build.gradle.kts
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.4/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    id("org.jetbrains.kotlin.jvm") version "1.9.10"

    // Apply the application plugin to add support for building a CLI application in Java.
    application
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use the Kotlin JUnit 5 integration.
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")

    // Use the JUnit 5 integration.
    testImplementation("org.junit.jupiter:junit-jupiter-engine:5.9.3")

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation("com.google.guava:guava:32.1.1-jre")
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(20))
    }
}

application {
    // Define the main class for the application.
    mainClass.set("com.example.hello.AppKt")
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}

```

I think the auto generated comments for the `build.gradle.kts` are actually pretty good. This is close to the minimal setup required to build a Kotlin application targeting the JVM. You could strip it of some things and it would still work, for example you don't need to define a test task, nor do you explicitly need like any of the dependencies it imports. 

`java { toolchain {}}` This matters for Kotlin applications targeting the JVM. If your language level is above 20 it won't be supported by the current version of gradle (8). If for some reason you're integrating Kotlin code into another Java application, you need to generate compatible byte code for that project. There are a plethora of projects that still use Java 8 for example. So you'd want to set the JVM compilation target to 8. I used 20 because 20 has some cool features. I'll spoil them, it has [GraalVM Native Image Complination](https://www.graalvm.org/22.0/reference-manual/native-image/), wherein you can target the JVM and the JDK (like all of them?) include the part of GraalVM that can compile JVM bytecode to LLVM IR, and to assembly, making a platform native executable. It also has support for what was called [Project Loom](https://wiki.openjdk.org/display/loom/Getting+started) which is a [Green Thread](https://en.wikipedia.org/wiki/Green_thread)implementation, which essentially means instead of spawning OS processes or OS threads, there are lightweight application embedded threads that you can spawn gazillions of. 

```kotlin
// ❯ cat app/src/main/kotlin/com/example/hello/App.kt
/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.example.hello

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

fun main() {
    println(App().greeting)
}
```

Honestly not the simplest hello world in the world, you can actually just do a python style 


```kotlin
fun main(){
	println("Hello, World!")
}
```

But the beautiful part of the auto generated hello world code is it shows you a bunch of language constructs that should just make sense (hopefully). Also note it kind of looks like Java. 

Let's break it down.

**entrypoint**

In our `build.gradle.kts` we set the file that has our entrypoint ```

```kotlin
    mainClass.set("com.example.hello.AppKt")
```

This tells the compiler which file to look in for where the entry point should be. `fun main` is special, like in C. It's by convention known as the entrypoint when you make a file and point the compiler at it. But there's also other ways to make entry points, like in java, by using static companion classes. But I won't get into that. 

```kotlin
fun main() {
    println(App().greeting)
}
```

So we have `fun main`, it calls `prinln`, from the standard kotlin library, it makes an instance of `App()` and gets the property `greeting` from `class App`. 

```kotlin
class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}
```

If you've never seen this before, you're probably like oh yeah you mean it called greeting and it returned a string. Well yes, but no. In Kotlin (and Python has this too, as does Typescript, C# etc) you add access modifiers to class level properties.

So 

```kotlin
    val greeting: String
        get() {
            return "Hello World!"
        }
```


Is a class member that invokes get when the greeting property is accessed. You can also handle the case where someone tries to mutate your class property. 

#### Build Hello World

If you were doing this by hand (just imagine, it's not actually that hard), you would now run `gradle init`, but we already did that. 

But now, you can run `gradle build` and gradle will spawn a build daemon (the bane of my existence) and will then run your build scripts and compile your code. 

```bash
❯ ./gradlew build

BUILD SUCCESSFUL in 474ms
7 actionable tasks: 7 up-to-date

```

Now if we go check the build directory, we'll have build jars, which we can run. If you were doing [Kotlin Native](https://kotlinlang.org/docs/native-overview.html) Compilation you would also have binaries for your target system. Or if you were compiling to [Web Assembly](https://webassembly.org/) you would have build assets for compiled web assembly images, a la [Kotlin WASM](https://kotlinlang.org/docs/wasm-overview.html). Or if you were compiling [Kotlin for JavaScript](https://kotlinlang.org/docs/js-overview.html) you would have a directory for your JS bundle. The list goes on. The multitude of targets for Kotlin and the ability to share code, with the addition of build rules and coding by convention makes it very powerful and versatile. 

With that being said, let's run our JVM version of Kotlin!

#### Run Hello, World!

```bash
❯ ./gradlew run

> Task :app:run
Hello World!

BUILD SUCCESSFUL in 493ms
2 actionable tasks: 1 executed, 1 up-to-date
```

Wicked cool! ⭐️

### Retrospective

- Why did we do this 'The Hard Way'?
- That seemed pretty straightforward, was it really that 'Hard'
- What should I take away from this?

I'll answer all three of those questions right now. We did this `The Hard Way` because that's pretty much all the easy way does for us, just abstracted away from us. There is in fact a harder way, it's left as a trivial example to the reader to attempt to execute the build artifact as a jar with the java command. Was it really that `Hard`? If it hasn't clicked for you yet, yes it might seem hard. There are a decent number of steps required to do this the right way. But once it clicks, it's logically consistent, your brain buys into it, you learn its power. 

The biggest takeaway should be that understanding the underlying structure and process of setting up a Kotlin project gives you more control and insight into your development environment. While IDEs and auto-generation tools can make this process seem seamless, knowing how to set up a project manually:

- Enhances your understanding of the build system (Gradle in this case)
- Familiarizes you with the project structure and essential files
- Allows you to customize your setup more precisely when needed
- Prepares you to troubleshoot issues that might arise in more complex projects
- Provides a foundation for understanding how different components (like the build script, source files, and package structure) work together


By going through this process `The Hard Way` you've gained valuable knowledge about Kotlin project setup that will serve you well as you tackle more advanced development tasks and larger projects in the future.

Now check out [[The Easy Way]]